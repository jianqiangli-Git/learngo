# 数组
Go 中不允许混合不同类型的元素，但如果是 interface{} 类型数组，可以包含任意类型

数组类型是 `[n]T`
## 数组声明

```go
var a [3]int //声明长度为 3 的整型数组。数组中所有元素都被自动赋值为数组类型的零值。int 类型的零值是 0，a 的类型是 [3]int

a := [3]int{12, 78, 50}  //简短声明，并初始化

a := [3]int{12}   //声明 [12,0,0]

a := [...]int{12, 78, 50}  //长度用 ... 代替，自动计算长度
```
数组大小是类型的一部分，`[5]int` 和 `[25]int` 是不同类型。数组不能调整大小，可以用 `slice` 解决

## 数组是值类型而不是引用类型
这意味着当数组赋值给一个新的变量时，变量会得到一个原始数组的副本。如果对新变量进行更改，则不会影响原始数组。
```go
a := [...]string{"USA", "China", "India", "Germany", "France"}
b := a // a 的副本赋值给 b
b[0] = "Singapore"  //b 变 a 不变
```
当数组作为参数传递给函数时，它们是按值传递，而原始数组保持不变。
```go
func changeLocal(num [5]int) {
    num[0] = 55
    fmt.Println("inside function ", num)
}
func main() {
    num := [...]int{5, 6, 7, 8, 8}
    fmt.Println("before pass func", num) //[5 6 7 8 8]
    changeLocal(num)
    fmt.Println("after passi function ", num)  //[5 6 7 8 8]
}
```
`len(数组)` 可以得到数组长度
## 使用 range 迭代数组
`range` 返回索引 `index` 和该索引处的值 `value`
```go
func main() {
    a := [...]float64{67.7, 89.8, 21, 78}
    sum := float64(0)
    for i, v := range a { //for _, v := range 可以屏蔽 i
        fmt.Printf("%d of a is %.2f\n", i, v)
        sum += v
    }
    fmt.Println("\nsum of array:",sum)
}
```
## 多维数组
```go
a := [3][2]string{   //3x2
        {"lion", "tiger"},
        {"cat", "dog"},
        {"pigeon", "peacock"}, //末尾逗号是必需,因为 Go 规则自动插入分号
    }
```

# 切片
切片本身不拥有任何数据。它们只是对现有数组的引用。

切片类型为 `[]T`
## 创建切片
```go
a := [5]int{76, 77, 78, 79, 80}
var b []int = a[1:4] 
```


